---
chapter_no: 2
chapter_title: 関数
created: 2021-07-20
updated: 2021-07-20
---
### 関数宣言
- 関数は`function`キーワードを使って宣言します。  
- 引数を書く位置は、変数名の後の`()`の中か、本体の先頭部分の`Param()`の中のどちらかです[^arguments-position]。
- 戻り値は`return`キーワードのを使って書きます。
```syntax
{em:comment{# 引数なし}em}
function {em{関数名}em} {
    {em:comment{# 処理本体}em}
    return {em:blue{戻り値}em}
}

function {em{関数名}em}() {
    {em:comment{# 処理本体}em}
    return {em:blue{戻り値}em}
}

{em:comment{# 引数あり}em}
function {em{関数名}em}({em:blue{引数1, 引数2, …}em}) {
    {em:comment{# 処理本体}em}
    return {em:blue{戻り値}em}
}

function {em{関数名}em} {
    {em:blue{Param(
        引数1,
        引数2,
        …
    )}em}
    {em:comment{# 処理本体}em}
    return {em:blue{戻り値}em}
}
```
[^arguments-position]: 両方に書くと「function の宣言に引数が指定されている場合、param ステートメントを使用できません。」というエラーになります。

### 可変長引数
- 可変長引数は変数`$args`という配列に渡されます。  
- 普通に引数を渡した関数内でも`$args`で配列は参照できます。
  - その際、普通の引数に指定した方に先に値が割り当てられていき、*残った部分が`$args`に割り当てられます*。

```:function_variable_length_parameter.ps1
function foo {
    Write-Host {em{$args}em}.Count
    foreach($i in $args) {
        Write-Host $i
    }
}

function bar({em:blue{$a, $b}em}) {
    Write-Host "$({em{$args}em}.Count) a={em:blue{$a}em} b={em:blue{$b}em}"
    foreach($i in $args) {
        Write-Host $i
    }
}

# 呼び出し
Write-Host '--- call foo'
foo a b あいう
Write-Host '--- call bar 1'
bar 10 20 a b c あいう  {em:comment{# $a, $bに10, 20が割り当てられ、それ以降が$argsに割り当てられる}em}
Write-Host '--- call bar 2'
bar 10 20  {em:comment{# $a, $bに10, 20が割り当てられ、$argsには何も割り当てられず空リストになる}em}
```

```output:出力結果
{em:command{PS C:\temp>}em} .\function_variable_length_parameter.ps1
--- call foo
3
a
b
あいう
--- call bar 1
4 a=10 b=20
a
b
c
あいう
--- call bar 2
0 a=10 b=20
```

### 値渡し、参照渡し
- 値渡しは通常の操作です。関数の中で書き換えても呼び出し元の方の変数へは影響が及びません。
- 参照渡しをするには、変数にを`ref型`に変換(`[ref]`を付ける)して渡します。
  - 以下の例では、受け取る引数の方も`[ref]`を付けていますが、これは必須ではありません(省略可)。
  - ただ、明示的に`[ref]`を付けておいたほうが、参照渡しであることが分かりやすいので、付けておいたほうがいいかもしれません。

```:function_args_byval_byref.ps1
{em:comment{# 値渡し}em}
function byVal($arg) {
    $arg = 'Good bye!'
    Write-Host "in function(byVal): $arg"
}

{em:comment{# 参照渡し}em}
function byRef({em:blue{[ref]}em}$arg) {
    $arg{em{.Value}em} = 'Good bye!'
    Write-Host "in function(byRef): $($arg.Value)"
}
function byRef2($arg) {
    $arg{em{.Value}em} += '!!'
    Write-Host "in function(byRef2): $($arg.Value)"
}

$str = 'Hello'
$str
byVal $str  {em:comment{# 値渡し}em}
$str  {em:comment{# => Hello のまま}em}

byRef({em:blue{[ref]}em}$str)　{em:comment{# 参照渡し}em}
$str  {em:comment{# => Good bye! に書き換わっている}em}
byRef2({em:blue{[ref]}em}$str)　{em:comment{# 参照渡し}em}
$str  {em:comment{# => Good bye!!! に書き換わっている}em}
```

```output:出力結果
{em:command{PS C:\temp>}em} .\function_args_byval_byref.ps1
Hello
in function(byVal): Good bye!
Hello
in function(byRef): Good bye!
Good bye!
in function(byRef2): Good bye!!!
Good bye!!!
```

### 引数のデフォルト値
- 引数のデフォルト値を設定できます。
- 関数呼び出しの時に省略すると、その値が設定されます。
- 明示的に指定して上書きすることもできます。
```:function_args_default_value.ps1
function foo($arg {em{= 10}em}) {
    Write-Host "値は$($arg)です。"
}
function bar($arg1, $arg2 {em{= 10}em}) {
    Write-Host "値は$($arg1)と$($arg2)です。"
}

foo       {em:comment{# => 省略しているので、デフォルト値の10が出力される}em}
foo 20    {em:comment{# => 上書きして、20が出力される}em}

bar 15    {em:comment{# => $arg1に15が入って、$arg2はデフォルト値の10が入る}em}
bar 15 25 {em:comment{# => $arg1に15が入って、$arg2は上書きして25が入る}em}
```

```output:出力結果
{em:command{PS C:\temp>}em} .\function_args_default_value.ps1       
値は10です。
値は20です。
値は15と10です。
値は15と25です。
```
