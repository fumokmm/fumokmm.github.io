---
chapter_no: 12
chapter_group: 基礎文法
chapter_title: 型
created: 2022-10-05
updated: 2022-10-08
---
### 型推論
- Rustの場合は型推論させるのが一般的です。
```:型推論させた変数の使用例
fn main() {
    let name = "fumo";
    let age = 41;
}
```
- 型を宣言しておきたいときは `:` の後に変数の型を書きます。
```:型を宣言
fn main() {
    let name {em{: &str}em} = "fumo";
    let age {em{: i32}em} = 41;
}
```
- 文字列の型は`&str`。
- 数値の場合は主に`i32`を使います。`i32`は整数(integer)の32ビット版です。
- 最近のパソコンでは64ビットが主流なので`i64`でもOKです。
- 変数だけの時は型を指定する必要はありません。(型推論でOK)
- しかし、関数を作成する場合は型の指定が必須になります。

```:関数を作成する場合は型の指定が必須になる
fn add(x: {em{i32}em}, y: {em{i32}em}) -> {em{i32}em} {
    x + y
}
```
- `fn`は関数宣言の印です。
- add関数は引数xと引数yの2つを受け取って、加算して返すという簡単なものです。
- `->`が関数の戻り値です。

- 戻り値の型は関数の中で使われている計算結果の型と一致させなくてはならない。
```:コンパイルエラー
fn add(x: {em{i32}em}, y: {em{i32}em}) -> {em:blue{i64}em} {
    x + y
}
```
- 戻り値の型で指定した`i64`が間違っているためコンパイルエラーになります。
- x + yの型を`i64`型に変換するか、add関数の戻り値の型を`i32`型変更するかの2つの解決方法があります。

### 数値の型
<table class="normal">
	<tr>
		<th markdown="span">ビット長</th>
		<th markdown="span">整数</th>
		<th markdown="span">符号なし整数</th>
	</tr>
	<tr>
		<td markdown="span">8ビット</td>
		<td markdown="span">i8</td>
		<td markdown="span">u8</td>
	</tr>
	<tr>
		<td markdown="span">16ビット</td>
		<td markdown="span">i16</td>
		<td markdown="span">u16</td>
	</tr>
	<tr>
		<td markdown="span">32ビット</td>
		<td markdown="span">i32</td>
		<td markdown="span">u32</td>
	</tr>
	<tr>
		<td markdown="span">64ビット</td>
		<td markdown="span">i64</td>
		<td markdown="span">u64</td>
	</tr>
	<tr>
		<td markdown="span">処理系依存</td>
		<td markdown="span">isize</td>
		<td markdown="span">usize</td>
	</tr>
</table>

### 数値のリテラル
<table class="normal">
	<tr>
		<th markdown="span">数値リテラル</th>
		<th markdown="span">例</th>
	</tr>
	<tr>
		<td markdown="span">10進数</td>
		<td markdown="span">12_345</td>
	</tr>
	<tr>
		<td markdown="span">16進数</td>
		<td markdown="span">0xff</td>
	</tr>
	<tr>
		<td markdown="span">8進数</td>
		<td markdown="span">0o77</td>
	</tr>
	<tr>
		<td markdown="span">2進数</td>
		<td markdown="span">0b1111_0000</td>
	</tr>
	<tr>
		<td markdown="span">1バイト</td>
		<td markdown="span">b'A'</td>
	</tr>
</table>

### 浮動小数点数
<table class="normal">
	<tr>
		<th markdown="span">ビット長</th>
		<th markdown="span">浮動小数点数</th>
		<th markdown="span">備考</th>
	</tr>
	<tr>
		<td markdown="span">32ビット</td>
		<td markdown="span">f32</td>
		<td markdown="span">単精度浮動小数点数</td>
	</tr>
	<tr>
		<td markdown="span">64ビット</td>
		<td markdown="span">f64</td>
		<td markdown="span">倍精度浮動小数点数</td>
	</tr>
</table>
```
fn main() {
    let x = 100.234;
    println!("x is {}", x);
    let y : f64 = 100.234;
    println!("y is {}", y);
}
```

### 論理値
`true`と`false`の2つのみ値を持つ。`bool型`。
```
fn main() {
    let b = true;
    println!("b is {}", b);
}
```

### 文字型
- `char型`を使います。
- アルファベットやひらがななどをシングルクォート(`'`)で囲みます。
```
fn main() {
    let c = 'A';
    println!("c is {}", c);
    let c = 'あ';
    println!("c is {}", c);
    let dog = '🐶';
    println!("dog is {}", dog);
    let cat : char = '😸';
    println!("cat is {}", cat);
}
```

### 文字列型

#### &str型とString型
- Rustの文字列には`&str型`と`String型`があります。
- 文字列の扱いは*所有権(ownership)*や*借用(borrow)*を特に気をつける必要があります。
- `println!マクロ`を使ってコンソールに表示するだけなら、以下サンプルで十分です。

```:ステークホルダー{}を指定したprintln!の使用例
fn main() {
    let dog = "DOG";
    let cat = "CAT";
    println!("{} and {}", dog, cat);
}
```
```output:出力結果
DOG and CAT
```
- ここで使われる方は`&str型`です。
- `let`を使って変数を使う限りは特に気にする必要はありません。

#### Rustの標準ライブラリString型を使う方法
```:String::from関数
fn main() {
    let s = {em{String::from("Hello Rust!");}em}
    println!("{}", s);
}
```
```output:出力結果
Hello Rust!
```
- `String型`の`from関数`を使って文字列の初期化ができます。
  - やっていることは`&str`と同じです。
- `String型`にしておく理由は受け取った文字列を更新したいときに便利だからです。

```:更新の例「＋」演算子
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from("Rust");
    let s3 = String::from("World.");
    {em{let s = s1 + " " + }em}{em:blue{&s2}em}{em{ + " " + }em}{em:blue{&s3}em}{em{;}em}
    println!("{}", s);
}
```
```output:出力結果
Hello Rust World.
```
- `s2`と`s3`に`&(アンパサンド)`がついているのは*借用*の印です。

#### 実際はformat!マクロを使うと便利
```:format!マクロ
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from("Rust");
    let s3 = String::from("World.");
    let s = {em{format!("{} {} {}", s1, s2, s3);}em}
    println!("{}", s);
}
```
```output:出力結果
Hello Rust World.
```
- `format!マクロ`では数値や文字列を連結して1つの文字列にして返してくれます。


`String::from関数`でなくて`"(ダブルクォート)`を使って直接文字列を代入する方法でも`format!マクロ`は使えます。
```:直接文字列を代入する方法
fn main() {
    {em{let s1 = "Hello";
    let s2 = "Rust";
    let s3 = "World.";}em}
    let s = {em{format!("{} {} {}", s1, s2, s3);}em}
    println!("{}", s);
}
```
```output:出力結果
Hello Rust World.
```
- Rustの文字列の扱いはUTF-8と配列がややこしく絡み合っているので結構注意が必要です。
- あまりややこしいことをしなければ、`String::from関数`と`format!マクロ`でそこそこまでいけます。

### サンプルソース
- [(language-examples) n0002_string](https://github.com/fumokmm/language-examples/tree/main/Rust/n0002_string)

### 参考書籍
- {% include book/book_945.html %} {% comment %} プログラミング言語Rust入門 {% endcomment %}
