/**
 * 引数 -Ptargetにカンマ区切りで、_articlesのパスをカンマ区切りで指定した場合、
 * その全てが含まれる場合のみ、対象makeArticlesの対象となります。
 * targetの値に "all" のみ指定されている場合に限り、全てのファイルを対象とします。
 * 例: $ ./gradlew makeArticles -Ptarget=/groovy,/git
 */
task makeArticles() {
    group = '記事管理'
    description = '_articles配下の記事を結合して、.workに記事を作成します。(オプション: -Ptarget=xxx)'
    dependsOn 'checkUpdated' // 記事生成前に更新日付が更新されていること

    doFirst {
        def dirs = []
        categoryList
        .each { category ->
            def fileTree = fileTree("${projectDir}/_articles/${category}/")
            fileTree.include "*/*"
            fileTree.visit { vis ->
                // 4つ親がプロジェクトディレクトリとなるディレクトリを取得
                if (vis.file.directory && vis.file.parentFile.parentFile.parentFile.parentFile == projectDir) {
                    if (project.hasProperty('target')) {
                        if (project.target == 'all' ||
                            project.target.split(',')*.trim().any{ vis.file.absolutePath.contains(it) }
                        ) {
                            dirs << [dir: vis.file, category: category]
                        }
                    } else {
                        dirs << [dir: vis.file, category: category]
                    }
                }
            }
        }

        // ディレクトリ内の .mdを操作
        dirs.each{ dir ->
            def topArticle = dir.dir.listFiles().find{ it.name == 'index.md' }
            assert topArticle, "${dir.dir}にindex.mdがあるはず"
            def chapters = dir.dir.listFiles().findAll{ it.name != 'index.md' }

            // チャプターがあるかどうか
            boolean hasChapter = chapters.size() > 0

            def toPath = new File(topArticle.parentFile.absolutePath.replace("${projectDir}/_articles/${dir.category}", "${projectDir}/.work/articles/${dir.category}") + '.md')
            println "${toPath}"
            toPath.parentFile.mkdirs()
            toPath.delete()

            // チャプターグループを含んでいればチャプターグループ
            boolean hasChapterGroup = false

            def chapterMap = [:] as TreeMap
            chapters.each { chap ->
                //println "  > ${chap}"
                def frontMatter = [:]
                def body = '' << '' // as StringBuilder
                chap.withReader{ reader ->
                    reader.readLine() // 先頭の ---は飛ばす
                    def line = ''
                    while (line != '---') {
                        switch (line) {
                            case ~/^chapter_no:.*/    : frontMatter['chapter_no'] = line.split(':')[1].trim().toInteger(); break
                            case ~/^chapter_id:.*/    : frontMatter['chapter_id'] = line.split(':')[1].trim(); break
                            case ~/^chapter_title:.*/ : frontMatter['chapter_title'] = line.split(':')[1].trim(); break
                            case ~/^created:.*/       : frontMatter['created'] = Date.parse('yyyy-MM-dd', line.split(':')[1].trim()); break
                            case ~/^updated:.*/       : frontMatter['updated'] = Date.parse('yyyy-MM-dd', line.split(':')[1].trim()); break
                            // チャプターグループ関連定義
                            case ~/^chapter_group:.*/ :
                                frontMatter['chapter_group'] = line.split(':')[1].trim()
                                hasChapterGroup = true
                                break
                        }
                        line = reader.readLine()
                    }

                    boolean isInnerTable = false
                    def innerTableBody = '' << '' // as StringBuilder
                    def escapeHtmlTag = {
                        it.replaceAll(/&/, '&amp;')
                          .replaceAll(/\</, '&lt;')
                          .replaceAll(/\>/, '&gt;')
                    }
                    def convertToEmTag = { innerBody ->
                        // {em:<種類>{ で開始して、 }em} で終わる部分を <em class="<種類>">値</em>に変換
                        innerBody.replaceAll(/(?s)\{em:?(blue|comment|command)?\{(.*?)\}em\}/) { match, type, value ->
                            "<em${type ? " class=\"${type}\"": ''}>${value}</em>"
                        }
                    }
                    while(true) {
                        line = reader.readLine()
                        if (line == null) break

                        // 行を読み取ってbodyに追加
                        // テーブル定義マクロ内かどうか
                        if (! isInnerTable) {
                            if (! line.startsWith('```')) {
                                body << line << '\n'

                            } else {
                                isInnerTable = true
                                // オプションを取得
                                def opt = line.replaceFirst(/^```/, '').with {
                                    if (it == '') [:]
                                    else {
                                        it.contains(':') ?
                                            it.split(':').with { [type: it.head().trim(),
                                                                  title: it.tail().join(':').trim()] } :
                                            [type: it]
                                    }
                                }
                                body << "<div class=\"code-box${opt && opt.type ? '-' + opt.type : ''}${!opt || !opt.title ? ' no-title' : ''}\">" << '\n'
                                if (opt && opt.title) {
                                    body << "<div class=\"title\">${opt.title}</div>" << '\n'
                                }
                                body << '<pre>' << '\n'
                                innerTableBody.length = 0
                            }

                        } else {
                            if (! line.startsWith('```')) {
                                innerTableBody << line << '\n'

                            } else {
                                isInnerTable = false
                                // 関数合成でescapeHtmlTagしてから、convertToEmTagする
                                body << (escapeHtmlTag >> convertToEmTag)(innerTableBody.toString())
                                body << '''|</pre>
                                           |</div>'''.stripMargin() << '\n'
                            }
                        }
                    }
                }

                // chapter_id: があって chapter_title: がない場合、chapter_titleをchapter_idで補う
                if (frontMatter.containsKey('chapter_id') && !frontMatter.containsKey('chapter_title')) {
                    frontMatter['chapter_title'] = frontMatter.chapter_id

                // chapter_title: があって chapter_id: がない場合、chapter_idをchapter_titleで補う
                } else if (frontMatter.containsKey('chapter_title') && !frontMatter.containsKey('chapter_id')) {
                    frontMatter['chapter_id'] = frontMatter.chapter_title
                }

                chapterMap[frontMatter.chapter_no] = [file: chap,
                                                      frontMatter: frontMatter,
                                                      body: body.toString()]
            }

            // チャプターグループ定義である条件
            def isChapGroupDef = { it.frontMatter.containsKey('chapter_group') &&
                                   it.frontMatter.size() == 2 }

            // 通常の目次部分
            def doWriteIndexNormal = { writer ->
                writer << topArticle.text << '\n'
                writer << "## <a name=\"index\">目次</a><a class=\"heading-anchor-permalink\" href=\"#目次\">§</a>" << '\n'
                writer << '\n'
                writer << "<ul id=\"index_ul\">" << '\n'
                chapterMap.each { chapter_no, chap ->
                    writer << "<li><a href=\"#${ chap.frontMatter.chapter_id }\">${ chap.frontMatter.chapter_title }</a></li>" << '\n'
                }
                writer << "</ul>" << '\n'
                writer << '\n'
            }

            // 目次部分 (チャプターグループあり)
            def doWriteIndexChapterGroup = { writer ->
                def chapterGroups = chapterMap.groupBy{ chapter_no, chap -> chap.frontMatter.chapter_group }
                writer << topArticle.text << '\n'
                writer << "## <a name=\"index\">目次</a><a class=\"heading-anchor-permalink\" href=\"#目次\">§</a>" << '\n'
                writer << '\n'
                writer << '<div style="column-count: 2;">' << '\n'
                writer << "    <ul id=\"index_ul\">" << '\n'

                chapterGroups.each{ chapterGroup, chapterGroupItems ->
                    def (groupLabelItem, chapterItems) =
                        chapterGroupItems.values().groupBy{ isChapGroupDef(it) }.with {
                            [ it[true].first(),
                              it[false].sort{ it.frontMatter.chapter_no } ]
                        }

                    writer << "        <li><a href=\"#${chapterGroup}\">${chapterGroup}</a>" << '\n'
                    writer << '            <ul>' << '\n'
                    chapterItems.each { chapterItem ->
                    writer << "                <li><a href=\"#${ chapterItem.frontMatter.chapter_id }\">${ chapterItem.frontMatter.chapter_title }</a></li>" << '\n'
                    }
                    writer << '            </ul>' << '\n'
                    writer << '        </li>' << '\n'
                }
                writer << '    </ul>' << '\n'
                writer << '</div>' << '\n'
                writer << '\n'
            }

            // Bodyのみ
            def doWriteBodyOnly = { writer ->
                writer << topArticle.text << '\n'
            }

            // 通常のBody (チャプターグループなし)
            def doWriteBodyNormal = { writer, chapter_no, chap ->
                writer << '* * *' << '\n'
                writer << "## <a name=\"${chap.frontMatter.chapter_id}\">${chap.frontMatter.chapter_title}</a><a class=\"heading-anchor-permalink\" href=\"#${chap.frontMatter.chapter_id}\">§</a>" << '\n'
                writer << "<div class=\"chapter-updated\">{% include update_info_inline.html created=\"${chap.frontMatter.created.format('yyyy-MM-dd')}\" updated=\"${chap.frontMatter.updated.format('yyyy-MM-dd')}\" %}</div>" << '\n'
                writer << chap.body << '\n'
                writer << "{% include goto_pagetop.html %}" << '\n'
                writer << '\n'
            }

            // Body (チャプターグループあり)
            def doWriteBodyChapterGroup = { writer, chapter_no, chap ->
                if ( isChapGroupDef(chap)) {
                    writer << "## <a name=\"${chap.frontMatter.chapter_group}\">${chap.frontMatter.chapter_group}</a><a class=\"heading-anchor-permalink\" href=\"#${chap.frontMatter.chapter_group}\">§</a>" << '\n'
                } else {
                    writer << '* * *' << '\n'
                    writer << "## <a name=\"${chap.frontMatter.chapter_id}\">${chap.frontMatter.chapter_title}</a><a class=\"heading-anchor-permalink\" href=\"#${chap.frontMatter.chapter_id}\">§</a>" << '\n'
                    writer << "<div class=\"chapter-updated\">{% include update_info_inline.html created=\"${chap.frontMatter.created.format('yyyy-MM-dd')}\" updated=\"${chap.frontMatter.updated.format('yyyy-MM-dd')}\" %}</div>" << '\n'
                    writer << chap.body << '\n'
                    writer << "{% include goto_pagetop.html %}" << '\n'
                    writer << '\n'
                }
            }

            // 注釈部分
            def doWriteFootnotes = { writer ->
                writer << "{% include footnotes_link.html %}" << '\n'
            }

            ////////////////////////////////
            // 書き込み実施

            // チャプターがある場合
            if (hasChapter) {
                toPath.withWriterAppend(hasChapterGroup ?
                    doWriteIndexChapterGroup :
                    doWriteIndexNormal)

                chapterMap.each { chapter_no, chap ->
                    toPath.withWriterAppend { writer ->
                        doWriteBodyChapterGroup(writer, chapter_no, chap)
                    }
                }

            // チャプターがない場合 (Bodyのみ)
            } else {
                toPath.withWriterAppend doWriteBodyOnly
            }

            // 注釈部分の書き込み
            toPath.withWriterAppend doWriteFootnotes
        }
    }
}
